chapter 2
예제 부터 해봅시다
우리는 해봐야알어


녹색 사과를 찾고싶어요 -> 150 그램 이상 사과를 찾고싶어요 -> 시불 둘다 하고싶어요

시시각각 변하는 사용자 요구사항(극혐)

> 출발점 : 엔지니어링 비용이 적고, 쉽게 구현할수 있으며, 유지보수가 쉬우면 좋겠다.
> 설계를 잘해보자

동적파라미터화
		-> 자주 바뀌는 요구사항에 대한 내용을 효과적으로 대응 가능.
		-> 어떠케 실행살지 결정하지 않은 코드블럭을 제공하고, 코드 블럭에 들어갈 내용은 런타임중에 호출.


2.1.1 첫번째 시도 : Test1

	public static List<Apple> filterGreenApples(List<Apple> inventory) {
		List<Apple> result = new ArrayList<>();
		for (Apple apple : inventory) {
			if (Color.GREEN.equals(apple.getColor())) {
				result.add(apple);
			}
		}
		return result;
	}
	
	녹색사과 필터링 한거 같음.
	
	갑자기 빨간 사과를..?
	
2.1.2 두번째 시도 , 색을 파라미터화 : Test2

	filterGreenApples 의 코드를 반복하지않고, filterRedApples를 만드려면..
	
	메소드에 파라미터를 추가해서 좀 더 유연하게 할수있음
	

	public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
		List<Apple> result = new ArrayList<>();
		for (Apple apple : inventory) {
			if (color.equals(apple.getColor())) {
				result.add(apple);
			}
		}
		return result;
	}

	public static List<Apple> filterGreenApples(List<Apple> inventory) {
		return filterApplesByColor(inventory, Color.GREEN);
	}
	
	public static List<Apple> filterRedApples(List<Apple> inventory) {
		return filterApplesByColor(inventory, Color.RED);
	}
	
	
	근데 갑자기 무거운거 안무거운거 로 나누고시퐁
	
	public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
		List<Apple> result = new ArrayList<>();
		for (Apple apple : inventory) {
			if (apple.getWeight() > weight) {
				result.add(apple);
			}
		}
		return result;
	}
	
	추가...
	
	좋은 해결책은 맞음 
	하지만, 리스트를 만들고, 포 루프를 돌려서 필터를 하고 맞으면 리스트에 넣고
	이런 일련의 행동들이 중복이다 이말임.
	
	이런소스는 소프트웨어 공학의 DRY( Don't repeat yourself)를 위반하는 거임. 존내 기본적인 내용.
	
	만약 탐색과정을 수정한다믄? -> 두개를 다수정해서 .. 어쩌구저쩌구.. 
	엔지니어링적으로 비싼 대가를 치러야함
	
	filter라는 메소드로 합쳐볼까..?
	
2.1.3 세번째 시도 Test3
	
	public static List<Apple> filter(List<Apple> inventory, Color color, int weight, boolean flag) {
		List<Apple> result = new ArrayList<>();
		for (Apple apple : inventory) {
			if ((flag && color.equals(apple.getColor())) 
					|| (!flag && apple.getWeight() > weight)) {
				result.add(apple);
			}
		}
		return result;
	}
	
	과연 이거이 옳은 방법일까?
	개발자 맞냐?
	
	filter(inventory, Color.GREEN, 0, true);
	filter(inventory, null, 160, false);
		
	기능은 돌아갈지 몰라도 최악의 소스다. 
	
	true/false는 뭘뜻하는지도 모르겠고, 필터링의 조건이 바뀐다면.. 거의 새로 개발해야됨.
	
	동작 파라미터화를 이용해보자.
	
2.2 동작 파라미터화

참 또는 거짓을 반환하는 함수를 프레디케이트 라고 함.
선택조건을 결정하는 인터페이스를 정의해보자.


public interface ApplePredicate {
	boolean test(Apple apple);
}




	
	
	
	
	
	
	
	
	
	

	